
# https://ninja-build.org/manual.html
from ninja import ninja_syntax
import pybind11
import os, sysconfig, subprocess, platform, sys, dataclasses, time
from .config import CACHE_DIR, SRC_DIR, HEADER_DIR, BUILD_DIR, BIN_DIR
from .jit_utils import initEigenSrc, checkCommandExists

eigen_version = "3.4.0"
eigen_src_path = os.path.join(CACHE_DIR, f"eigen{eigen_version}")
ensureEigen = lambda : initEigenSrc(eigen_src_path, eigen_version)


@dataclasses.dataclass(frozen=True)
class PlatformBasicConfig:

    ext_suffix = sysconfig.get_config_var("EXT_SUFFIX")
    obj_suffix = ".obj" if platform.system() == "Windows" else ".o"
    py_includes = sysconfig.get_config_var('INCLUDEPY')

def _getPathToThisCompile(m_name: str):
    # m_name: module name
    return {
        "bin": os.path.join(BIN_DIR, m_name),
        "scripts": os.path.join(BUILD_DIR, "scripts_"+ m_name),
        "lib": os.path.join(BIN_DIR, "lib"),
    }

def _writeNinja(
        feat_dim: int, 
        cxx = "g++", 
        additional_compile_flags = [],
        additional_link_flags = []
        ):
    if not checkCommandExists(cxx):
        raise RuntimeError(f"{cxx} not found.")

    module_name = _get_module_name(feat_dim)
    __path = _getPathToThisCompile(module_name)
    script_dir = __path["scripts"]
    bin_dir = __path["bin"]
    lib_dir = __path["lib"]

    ninja_build_file = os.path.join(script_dir, "build.ninja")
    for _d in [bin_dir, lib_dir, script_dir]:
        if not os.path.exists(_d):
            os.makedirs(_d, exist_ok=True)
    
    __lock_file = os.path.join(script_dir, "writing.lock")
    __wait_time = 0
    __reuse = False
    while os.path.exists(__lock_file):
        __wait_time += 0.1
        __reuse = True  # if the lock file exists, it means the module is being built by another process
        time.sleep(0.1)
        if __wait_time > 3:
            raise RuntimeError(
                "Waiting for lock file timeout. Please check if there is another build process running.\n"
                "If not, please remove the lock file at '{}' manually.".format(__lock_file)
                )
    if __reuse:
        # should be written by another concurrent process
        return module_name, script_dir, bin_dir

    open(__lock_file, "w").close()
    with open(ninja_build_file, "w") as build_file:
        writer = ninja_syntax.Writer(build_file)
        writer.comment("This file is generated by build.py")

        to_compile = [ "vecdbImpl", "searchAlgorithm" ]
        to_compile_lib = [ "b64enc" ]

        if cxx == "g++" or cxx == "clang++":
            cxx_flags = [
                "-std=c++17",
                "-Wall",
                f"-I{eigen_src_path}",
                f"-I{PlatformBasicConfig.py_includes}",
                f"-I{pybind11.get_include()}",
                f"-I{HEADER_DIR}",
                f"-DFEAT_DIM={feat_dim}",
                f"-DMODULE_NAME={module_name}",

                ## Optimization flags
                "-DNDEBUG",
                "-O2",
                "-funroll-loops",
            ] + additional_compile_flags

            if platform.system() == "Windows":
                cxx_flags += [ "-DYNAMICBASE" ]
            else:
                cxx_flags += [ "-fPIC" ]

            link_flags = [
                "-shared",
                "-lstdc++",
                # "-static"
            ] + additional_link_flags
            if platform.system() == "Darwin":
                link_flags.append("-undefined dynamic_lookup")

            writer.variable("CXX", cxx)
            writer.variable("CXX_FLAGS", " ".join(cxx_flags))
            writer.variable("LINK_FLAGS", " ".join(link_flags))

            writer.rule("compile", "$CXX -MMD -MF $out.d $CXX_FLAGS $in -c -o $out", depfile="$out.d", description="compile $out")
            for _m in to_compile:
                writer.build(os.path.join(bin_dir, f"{_m}{feat_dim}{PlatformBasicConfig.obj_suffix}"), "compile", os.path.join(SRC_DIR, f"{_m}.cpp"))
            for _m in to_compile_lib:
                writer.build(os.path.join(lib_dir, f"{_m}{PlatformBasicConfig.obj_suffix}"), "compile", os.path.join(SRC_DIR, f"{_m}.cpp"))
            
            writer.rule("link", "$CXX $LINK_FLAGS $in -o $out", description="link $out")
            writer.build(os.path.join(bin_dir, f"{module_name}{PlatformBasicConfig.ext_suffix}"), "link", \
                            [os.path.join(bin_dir, f"{_m}{feat_dim}{PlatformBasicConfig.obj_suffix}") for _m in to_compile] + \
                            [os.path.join(lib_dir, f"{_m}{PlatformBasicConfig.obj_suffix}") for _m in to_compile_lib])
        
        elif cxx == "cl" and platform.system() == "Windows":
            # TODO: to be implemented...
            ...

        else:
            raise NotImplementedError(f"Unsupported compiler: {cxx} in {platform.system()}")
    os.remove(__lock_file)
        
    return module_name, script_dir, bin_dir

def _get_module_name(feat_dim):
    return f"vecdbImpl{feat_dim}"

def compile(
        feat_dim, 
        quite = False, 
        cxx: str = "g++",
        additional_compile_flags = [],
        additional_link_flags = []
        ) -> str:
    
    if not os.getenv("TVDB_FORCE_COMPILE", False):
        # if the module is already compiled, return the module name
        _m_name = _get_module_name(feat_dim)
        _bin_dir = _getPathToThisCompile(_m_name)["bin"]
        _aim_file = os.path.join(_bin_dir, f"{_m_name}{PlatformBasicConfig.ext_suffix}")
        if os.path.exists(_aim_file):
            return f"{_bin_dir}.{_m_name}".split(os.path.sep)[-1]

    # else, compile the module, 
    module_name, script_dir, bin_dir = _writeNinja(
        feat_dim, 
        cxx=cxx, 
        additional_compile_flags=additional_compile_flags, 
        additional_link_flags=additional_link_flags
        )

    def print_(*args, **kwargs):
        if not quite:
            print(*args, **kwargs)
    SP_STDOUT = subprocess.DEVNULL if quite else sys.stdout

    print_("\033[1;30m", end="\r")
    print_("----------------------------------------")

    subprocess.check_call(["ninja", "-t", "commands"], cwd = script_dir, stdout=SP_STDOUT)
    print_("----------------------------------------")

    __buid_lock = os.path.join(script_dir, "building.lock")
    _sleep_time = 0
    _reuse = False
    while os.path.exists(__buid_lock):
        time.sleep(0.1)
        _reuse = True   # if the lock file exists, it means the module is being built by another process
        _sleep_time += 0.1
        if _sleep_time > 10:
            raise RuntimeError(
                "Waiting for building timeout. Please check if there is another build process running.\n"
                "If not, please remove the lock file at '{}' manually.".format(__buid_lock)
                )
    if _reuse and os.path.exists(os.path.join(bin_dir, f"{module_name}{PlatformBasicConfig.ext_suffix}")):
        # return without building it again
        return f"{bin_dir}.{module_name}".split(os.path.sep)[-1]

    open(__buid_lock, "w").close()
    try:
        subprocess.check_call("ninja", cwd = script_dir, stdout=SP_STDOUT)
    except subprocess.CalledProcessError as e:
        raise e
    finally:
        os.remove(__buid_lock)

    with open(os.path.join(script_dir, "compile_commands.json"), "w") as f:
        # ninja -t compdb > compile_commands.json
        subprocess.check_call(["ninja", "-t", "compdb"], cwd = script_dir, stdout=f, stderr=SP_STDOUT)

    print_("\033[0m", end="\r")
    return f"{bin_dir}.{module_name}".split(os.path.sep)[-1]